/* Kartik Arora
https://www.youtube.com/watch?v=ot-F649XKVk&list=PLb3g_Z8nEv1i6NHntG5l2fPKuVu853EYy
*/
#include <bits/stdc++.h>
using namespace std;

using Matrix = vector<vector<long long>>;
const long long MOD = 1e9+7; // optional, remove if not needed

// Multiply matrix A (n x m) with matrix B (m x p) -> result (n x p)
Matrix multiplyMatrices(const Matrix &A, const Matrix &B) {
    int n = A.size();
    int m = A[0].size();
    int p = B[0].size();
    Matrix C(n, vector<long long>(p, 0));

    for(int i = 0; i < n; i++) {
        for(int k = 0; k < m; k++) {
            for(int j = 0; j < p; j++) {
                C[i][j] = (C[i][j] + A[i][k] * B[k][j]) % MOD;
            }
        }
    }
    return C;
}

// Fast exponentiation of a square matrix A^x
Matrix matrixExponentiation(Matrix A, long long x) {
    int n = A.size();
    // Initialize identity matrix
    Matrix result(n, vector<long long>(n, 0));
    for(int i = 0; i < n; i++) result[i][i] = 1;

    while(x > 0) {
        if(x & 1) result = multiplyMatrices(result, A);
        A = multiplyMatrices(A, A);
        x >>= 1;
    }
    return result;
}

int main() {
    int n;
    long long power;
    cin >> n >> power;

    Matrix A(n, vector<long long>(n));
    cout << "Enter matrix:\n";
    for(int i = 0; i < n; i++) {
        for(int j = 0; j < n; j++) {
            cin >> A[i][j];
        }
    }

    Matrix result = matrixExponentiation(A, power);

    cout << "Resultant Matrix:\n";
    for(int i = 0; i < n; i++) {
        for(int j = 0; j < n; j++) {
            cout << result[i][j] << " ";
        }
        cout << "\n";
    }
    return 0;
}
